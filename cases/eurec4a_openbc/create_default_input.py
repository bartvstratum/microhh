#
# MicroHH
# Copyright (c) 2011-2023 Chiel van Heerwaarden
# Copyright (c) 2011-2023 Thijs Heus
# Copyright (c) 2014-2023 Bart van Stratum
#
# This file is part of MicroHH
#
# MicroHH is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MicroHH is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with MicroHH.  If not, see <http://www.gnu.org/licenses/>.
#

import argparse

import netCDF4 as nc4
import xarray as xr
import pandas as pd
import numpy as np

# Custom modules, from `microhh/python/`.
import microhh_tools as mht

# Custom scripts from same directory.
from global_settings import dtype, work_path, cosmo_path, start_date, end_date
import helpers as hlp

# Grid (horizontal/vertical) definition.
import grid_definition as gd

# Parse command line arguments.
parser = argparse.ArgumentParser(description='EUREC4A openBC MicroHH setup')
parser.add_argument(
        '-d', '--domain', required=True,
        help='Name of domain ("inner" or "outer")')
args = parser.parse_args()

if args.domain not in ('inner', 'outer'):
    raise Exception('Invalid domain choice.')

dates = pd.date_range(start_date, end_date, freq='h')
time_sec = np.array((dates-dates[0]).total_seconds()).astype(np.int32)


"""
Read grid info, and calculate spatial interpolation factors.
"""
if args.domain == 'inner':
    hgrid = gd.hgrid_inner
else:
    hgrid = gd.hgrid_outer

vgrid = gd.vgrid
dim_xy = (hgrid.jtot, hgrid.itot)

lon_slice = slice(hgrid.lon.min()-0.5, hgrid.lon.max()+0.5)
lat_slice = slice(hgrid.lat.min()-0.5, hgrid.lat.max()+0.5)

ds_2d, _ = hlp.read_cosmo(start_date, cosmo_path, lon_slice, lat_slice, read_3d=False)

if_s = hlp.Calc_xy_interpolation_factors(
        ds_2d.rlon.values, ds_2d.rlat.values,
        hgrid.lon, hgrid.lat,
        hgrid.itot, hgrid.jtot,
        dtype)


"""
Process hourly surface COSMO fields: SST (thl_bot) and qsat(SST) (qt_bot).
Unit conversions (T -> thl etc.) are done in `read_cosmo()`.
"""
print('Interpolating COSMO surface fields.')

for t, date in enumerate(dates):

    ds_2d, _ = hlp.read_cosmo(date, cosmo_path, lon_slice, lat_slice, read_3d=False)

    thl_s = np.empty(dim_xy, dtype)
    hlp.interpolate_cosmo(thl_s, ds_2d.thl_s.values, if_s, None, dtype)
    thl_s.tofile(f'{work_path}/thl_sbot_in.{time_sec[t]:07d}')

    qt_s = np.empty(dim_xy, dtype)
    hlp.interpolate_cosmo(qt_s, ds_2d.qsat_s.values, if_s, None, dtype)
    qt_s.tofile(f'{work_path}/qt_sbot_in.{time_sec[t]:07d}')


"""
Create `eurec4a_input.nc` file.
"""

# Read mean profiles, generated by `create_background.py`.
ds_time = xr.open_dataset('eurec4a_mean_profiles.nc')
ds_time = ds_time.sel(time=slice(start_date, end_date))
ds_mean = ds_time.mean(dim='time')

def add_var(nc_group, name, dims, values):
    var = nc_group.createVariable(name, dtype, dims)
    var[:] = values

nc_file = nc4.Dataset('eurec4a_input.nc', mode='w', datamodel='NETCDF4', clobber=True)
nc_file.createDimension('z', vgrid.ktot)
add_var(nc_file, 'z', ('z'), vgrid.z)

# Initial profiles. Not really used, but needed for `init` phase. The resulting
# initial 3D fields are overwritten by the interpolated fields from COSMO.
nc_init = nc_file.createGroup('init')
add_var(nc_init, 'thl', ('z'), ds_mean.thl.values)
add_var(nc_init, 'qt', ('z'), ds_mean.qt.values)
add_var(nc_init, 'u', ('z'), ds_mean.u.values)
add_var(nc_init, 'v', ('z'), ds_mean.v.values)

# Time dependent input. For now, spatially constant.
nc_tdep = nc_file.createGroup('timedep')
nc_tdep.createDimension('time_surface', time_sec.size)
nc_tdep.createDimension('time_ls', time_sec.size)

add_var(nc_tdep, 'time_surface', ('time_surface'), time_sec)
add_var(nc_tdep, 'time_ls', ('time_ls'), time_sec)

add_var(nc_tdep, 'p_sbot', ('time_surface'), ds_time.ps.values)
add_var(nc_tdep, 'u_geo', ('time_ls', 'z'), ds_time.ug.values)
add_var(nc_tdep, 'v_geo', ('time_ls', 'z'), ds_time.vg.values)

# Radiation.


nc_file.close()


"""
Create `eurec4a.ini` from eurec4a.ini.base`, with correct settings.
"""
ini = mht.Read_namelist('eurec4a.ini.base')

npx = gd.npx_inner if args.domain == 'inner' else gd.npx_outer
npy = gd.npy_inner if args.domain == 'inner' else gd.npy_outer

ini['master']['npx'] = npx
ini['master']['npy'] = npy

ini['grid']['itot'] = hgrid.itot
ini['grid']['jtot'] = hgrid.jtot
ini['grid']['ktot'] = vgrid.ktot

ini['grid']['xsize'] = hgrid.xsize
ini['grid']['ysize'] = hgrid.ysize
ini['grid']['zsize'] = vgrid.zsize

# Start buffer is quite low, but increases exponentially
# with height, so initial buffering is quite low.
ini['buffer']['zstart'] = 2/3 * vgrid.zsize

ini['time']['endtime'] = time_sec[-1]

ini.save(f'{work_path}/eurec4a.ini', allow_overwrite=True)
